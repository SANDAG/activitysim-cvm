import logging

import numpy as np
import pandas as pd

from ...core.util import reindex
from .ldt_pattern import LDT_PATTERN
from .util.tour_frequency import create_tours

logger = logging.getLogger(__name__)


def set_longdist_tour_index(tours):
    """
    The new index values are stable based on the person_id, tour_type, and tour_num.
    The existing index is ignored and replaced.

    This gives us a stable (predictable) tour_id with tours in canonical order
    (when tours are sorted by tour_id, tours for each person
    of the same type will be adjacent and in increasing tour_type_num order)

    It also simplifies attaching random number streams to tours that are stable
    (even across simulations)

    Parameters
    ----------
    tours : DataFrame
        Tours dataframe to reindex.
    """

    tour_num_col = "tour_type_num"
    # changed tours types to be more specific
    possible_tours = [
        "longdist_household1",
        "longdist_person_workrelated1",
        "longdist_person_other1",
    ]
    possible_tours_count = len(possible_tours)

    assert tour_num_col in tours.columns

    # create string tour_id corresonding to keys in possible_tours (e.g. 'work1', 'j_shopping2')
    tours["tour_id"] = tours.tour_type.str.lower() + tours[tour_num_col].map(str)

    # map recognized strings to ints
    tours.tour_id = tours.tour_id.replace(
        to_replace=possible_tours, value=list(range(possible_tours_count))
    )

    # convert to numeric - shouldn't be any NaNs - this will raise error if there are
    tours.tour_id = pd.to_numeric(tours.tour_id, errors="raise").astype(np.int64)

    tours.tour_id = (
        (tours.household_id * possible_tours_count * 100)
        + tours.person_id * 10
        + tours.tour_id
    )

    # if tours.tour_id.duplicated().any():
    #     print("\ntours.tour_id not unique\n%s" % tours[tours.tour_id.duplicated(keep=False)])
    #     print(tours[tours.tour_id.duplicated(keep=False)][['survey_tour_id', 'tour_type', 'tour_category']])
    assert not tours.tour_id.duplicated().any()

    tours.set_index("tour_id", inplace=True, verify_integrity=True)
    tours.index.name = "longdist_tour_id"

    # we modify tours in place, but return the dataframe for the convenience of the caller
    return tours


def process_longdist_tours(df, tour_counts, tour_category):
    """
    This method processes a tour_counts column and turns out a DataFrame that
    represents the long distance tours that were generated.

    Parameters
    ----------
    df: pandas.DataFrame
        persons or household table containing
    tour_counts : pandas.Series
        Matches the df, a tour frequency column
    tour_category : str
        A label for the type of tours

    Returns
    -------
    tours : DataFrame
        An example of a tours DataFrame is supplied as a comment in the
        source code - it has an index which is a unique tour identifier,
        a person_id column, and a tour type column which comes from the
        column names of the alternatives DataFrame supplied above.
    """

    tours = create_tours(tour_counts, tour_category=tour_category)

    if (
        "household_id" in df.columns
    ):  # only person dfs have a household_id column; processing persons here
        tours["household_id"] = reindex(df.household_id, tours.person_id)
        tours["origin"] = reindex(df.home_zone_id, tours.person_id)
    else:  # processing households here
        # TODO get smart about this, don't just assume we're in households...
        # wouldn't even people living alone technically be in households unless want to segment by GQ/household
        # create_tours returns ids as person_id, need to reassign to household_id
        tours["household_id"] = tours["person_id"]
        tours["origin"] = reindex(df.home_zone_id, tours.household_id)
        tours["person_id"] = reindex(df.min_person_id, tours.household_id)
        # hh tours attach a person from the household to simplify merging later
        # number of participants = hhsize since hh ldt tours are necessarily joint
        # (can remove if participation stage implemented)
        tours["number_of_participants"] = reindex(df.hhsize, tours.household_id)

    # assign stable (predictable) tour_id
    set_longdist_tour_index(tours)

    return tours

def process_longdist_trips(df):
    """
    This method processes the longdist_tours dataframe after the tour generation and pattern assignment steps
    and creates a longdist_trips dataframe, an individual-level record of all trips (both outgoing and return)
    that have been generated by ActivitySim.

    Parameters
    ----------
    df: pandas.DataFrame
        the longdist_tours table after tour generation and pattern assignment

    Returns
    -------
    trips : DataFrame
        Each record has a naive (0 to max) index that uniquely defines a trip,
        which is fundmentally a movement of an individual from an origin to 
        some destination. Each record also has a tour_id, corresponding to
        longdist_tours tours, which can be used to match trips to their
        respective tours. 
    """
    # list to store all the new trip rows
    new_rows = []
    # drop columns that shouldn't be in the trips df
    res = df.copy().reset_index().drop(["tour_type_count", "tour_type_num", "tour_num", "tour_count"], axis=1)
    
    # create broad trip purpose -- travel out or travel home
    res["purpose"] = np.where(((res["ldt_pattern"] & 3) == LDT_PATTERN.BEGIN) | ((res["ldt_pattern"] & 3) == LDT_PATTERN.COMPLETE), "travel_out", "")
    res["purpose"] = np.where((res["ldt_pattern"] & 3) == LDT_PATTERN.END, "travel_home", res["purpose"])
    
    # create logical destinations and origins that accurately describes a trip
    # e.g., for end trips, the destination would be a home_zone and the origin would 
    # be the ldt trip location a person is currently in
    res["destination"] = np.where((res["ldt_pattern"] & 3) == LDT_PATTERN.END, res["origin"], np.nan)
    res["origin"] = np.where((res["ldt_pattern"] & 3) == LDT_PATTERN.END, np.nan, res["origin"])
    
    # for each complete tour, add a corresponding travel home trip 
    # the travel out trip has already been generated above
    # these share a tour id with 
    for _, row in res[(res["ldt_pattern"] & 3) == LDT_PATTERN.COMPLETE].iterrows():
        new_row = row.copy()
        new_row["destination"] = new_row["origin"]
        new_row["origin"] = np.nan
        new_row["purpose"] = "travel_home"
        new_rows.append(pd.DataFrame(new_row).T)
    # add the copied tours array that was created earlier
    new_rows.append(res)
    
    # concat all trip df constituencies, sort them, and return them
    res = pd.concat(new_rows)
    res = res.sort_values("longdist_tour_id").reset_index(drop=True)
    
    return res 