Description,Target,Expression
# ,,"description describes the field, unimportant in actual program, target refers to the actual variable reference, expression is the value of the target"
,_MIN_VOT,setting('min_value_of_time')
,_MAX_VOT,setting('max_value_of_time')
,_MU,setting('distributed_vot_mu')
,_SIGMA,setting('distributed_vot_sigma')
income_segment,income_segment,"np.ceil(households.INCOME/15000).astype(int).clip(1,4)"
median_value_of_time,median_value_of_time,"income_segment.map({k: v for k, v in setting('household_median_value_of_time').items()})"
hh_value_of_time,hh_value_of_time,"rng.lognormal_for_df(df, mu=np.log(median_value_of_time * _MU), sigma=_SIGMA).clip(_MIN_VOT, _MAX_VOT)"
#,, annotate households table after import
,_PERSON_COUNT,"lambda query, persons, households: persons.query(query).groupby('household_id').size().reindex(households.index).fillna(0).astype(np.int8)"
number of workers,num_workers,"_PERSON_COUNT('ESR==2 | ESR==5', persons, households)"
number of students,num_students,"_PERSON_COUNT('SCH>=2', persons, households)"
number of drivers,num_drivers,"_PERSON_COUNT('16 <= AGE', persons, households)"
#,,FIXME households.income can be negative  - so we clip?
income_in_thousands,income_in_thousands,(households.INCOME / 1000).clip(lower=0)
min_person_id,min_person_id,"persons.reset_index().groupby('household_id')['person_id'].min().reindex(households.index)"
